// Generated by CoffeeScript 1.3.3
(function() {
  var __slice = [].slice;

  describe("Routing", function() {
    var Route, RouteOptions, navigate, setUrl, spy;
    Route = Spine.Route;
    RouteOptions = Route.options;
    spy = void 0;
    navigate = function() {
      var args, changed;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      changed = false;
      return $.Deferred(function(dfd) {
        Route.one('change', function() {
          return changed = true;
        });
        Route.navigate.apply(Route, args);
        waitsFor(function() {
          return changed === true;
        });
        return runs(function() {
          return dfd.resolve();
        });
      }).promise();
    };
    setUrl = (function() {
      var originalPath, originalTitle;
      originalTitle = void 0;
      originalPath = "" + window.location.pathname + window.location.search;
      return function(url) {
        return window.history.replaceState(null, originalTitle, url || originalPath);
      };
    })();
    beforeEach(function() {
      return Route.options = RouteOptions;
    });
    afterEach(function() {
      Route.unbind();
      Route.routes = [];
      return delete Route.path;
    });
    it("should have default options", function() {
      return expect(Route.options).toEqual({
        trigger: true,
        history: false,
        shim: false
      });
    });
    describe('With shim', function() {
      beforeEach(function() {
        return Route.setup({
          shim: true
        });
      });
      it("should not have bound any hashchange|popstate event to window", function() {
        var events;
        events = $(window).data('events') || {};
        return expect('hashchange' in events || 'popstate' in events).toBe(false);
      });
      it("can set its path", function() {
        expect(Route.path).toBeUndefined();
        Route.change();
        return expect(Route.path).toBeDefined();
      });
      it("can add a single route", function() {
        Route.add('/foo');
        return expect(Route.routes.length).toBe(1);
      });
      it("can add a bunch of routes", function() {
        Route.add({
          '/foo': function() {},
          '/bar': function() {}
        });
        return expect(Route.routes.length).toBe(2);
      });
      it("can add regex route", function() {
        Route.add(/\/users\/(\d+)/);
        return expect(Route.routes.length).toBe(1);
      });
      it("should trigger 'change' when a route matches", function() {
        var changed;
        changed = 0;
        Route.one('change', function() {
          return changed += 1;
        });
        Route.add("/foo", function() {});
        Route.navigate('/foo');
        waitsFor(function() {
          return changed > 0;
        });
        return runs(function() {
          return expect(changed).toBe(1);
        });
      });
      it("can navigate to path", function() {
        Route.add("/users", function() {});
        return navigate("/users").done(function() {
          return expect(Route.path).toBe("/users");
        });
      });
      it("can navigate to a path splitted into several arguments", function() {
        Route.add("/users/1/2", function() {});
        return navigate("/users", 1, 2).done(function() {
          return expect(Route.path).toBe("/users/1/2");
        });
      });
      return describe('With spy', function() {
        beforeEach(function() {
          var noop;
          noop = {
            spy: function() {}
          };
          spyOn(noop, "spy");
          return spy = noop.spy;
        });
        it("should trigger 'navigate' when navigating", function() {
          Route.one('navigate', spy);
          Route.add("/foo", function() {});
          Route.navigate('/foo');
          return expect(spy).toHaveBeenCalled();
        });
        it("should not navigate to the same path as the current", function() {
          Route.one('navigate', spy);
          Route.add("/foo", function() {});
          Route.path = '/foo';
          Route.navigate('/foo');
          expect(spy).not.toHaveBeenCalled();
          return expect(Route.path).toBe('/foo');
        });
        it("can call routes when navigating", function() {
          Route.add("/foo", spy);
          return navigate('/foo').done(function() {
            return expect(spy).toHaveBeenCalled();
          });
        });
        it("can call routes with params", function() {
          Route.add({
            "/users/:id/:id2": spy
          });
          return navigate('/users/1/2').done(function() {
            return expect(JSON.stringify(spy.mostRecentCall.args)).toBe(JSON.stringify([
              {
                trigger: true,
                history: false,
                shim: true,
                match: ["/users/1/2", "1", "2"],
                id: "1",
                id2: "2"
              }
            ]));
          });
        });
        it("can call routes with glob", function() {
          Route.add({
            "/page/*stuff": spy
          });
          return navigate("/page/gah").done(function() {
            return expect(JSON.stringify(spy.mostRecentCall.args)).toBe(JSON.stringify([
              {
                trigger: true,
                history: false,
                shim: true,
                match: ["/page/gah", "gah"],
                stuff: "gah"
              }
            ]));
          });
        });
        return it("can override trigger behavior when navigating", function() {
          expect(Route.options.trigger).toBe(true);
          Route.one('change', spy);
          Route.add("/users", function() {});
          Route.navigate('/users', false);
          waits(50);
          return runs(function() {
            expect(Route.options.trigger).toBe(true);
            return expect(spy).not.toHaveBeenCalled();
          });
        });
      });
    });
    describe('With hashes', function() {
      beforeEach(function() {
        return Route.setup();
      });
      afterEach(function() {
        return setUrl();
      });
      it("should have bound 'hashchange' event to window", function() {
        var events;
        events = $(window).data('events') || {};
        return expect('hashchange' in events).toBe(true);
      });
      it("should unbind", function() {
        var events;
        Route.unbind();
        events = $(window).data('events') || {};
        return expect('hashchange' in events).toBe(false);
      });
      it("can set its path", function() {
        delete Route.path;
        window.location.hash = "#/foo";
        Route.change();
        return expect(Route.path).toBe('/foo');
      });
      return it("can navigate", function() {
        Route.add("/users/1", function() {});
        return navigate("/users", 1).done(function() {
          return expect(window.location.hash).toBe("#/users/1");
        });
      });
    });
    return describe('With History API', function() {
      beforeEach(function() {
        return Route.setup({
          history: true
        });
      });
      afterEach(function() {
        return setUrl();
      });
      it("should have bound 'popstate' event to window", function() {
        var events;
        events = $(window).data('events') || {};
        return expect('popstate' in events).toBe(true);
      });
      it("should unbind", function() {
        var events;
        Route.unbind();
        events = $(window).data('events') || {};
        return expect('popstate' in events).toBe(false);
      });
      it("can set its path", function() {
        delete Route.path;
        setUrl('/foo');
        Route.change();
        return expect(Route.path).toBe('/foo');
      });
      return it("can navigate", function() {
        Route.add("/users/1", function() {});
        return navigate("/users/1").done(function() {
          return expect(window.location.pathname).toBe("/users/1");
        });
      });
    });
  });

}).call(this);
